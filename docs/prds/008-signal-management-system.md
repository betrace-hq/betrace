# PRD-008: Signal Management System

**Priority:** P0 (Core Feature)
**Complexity:** Medium
**Personas:** SRE, Developer, Compliance
**Dependencies:** PRD-002 (Persistence), PRD-007 (API validation)

## Problem

Signals are generated by rules but not properly managed:
- No CRUD APIs for signals
- No signal persistence (in-memory only)
- No signal status workflow (open → investigating → resolved)
- No signal search/filter
- `SignalService.java` exists but incomplete

## Solution

### Signal Lifecycle

```
open → investigating → resolved
  ↓
false_positive
```

### API Endpoints

```
POST   /api/signals              # Create signal (from rule firing)
GET    /api/signals              # List signals (with filters)
GET    /api/signals/{id}         # Get signal details
PATCH  /api/signals/{id}/status  # Update status
POST   /api/signals/{id}/notes   # Add investigation notes
DELETE /api/signals/{id}         # Soft delete
```

### Database Schema

Already defined in PRD-002 (signals table).

### Frontend

- Signal list table with filters
- Signal detail drawer
- Status update buttons
- Investigation notes textarea

## Success Criteria

- [ ] CRUD APIs work for signals
- [ ] Signals persist across restarts
- [ ] Status transitions enforced
- [ ] Real-time updates via WebSocket
- [ ] Search by trace ID, rule ID, severity, status
- [ ] Pagination for large signal lists
- [ ] Test coverage: CRUD, search, filtering

## Files to Create

- `backend/src/main/java/com/fluo/routes/SignalApiRoute.java`
- `backend/src/main/java/com/fluo/dto/SignalDto.java`
- `bff/src/lib/api/signals.ts`
- `bff/src/components/signals/signal-list.tsx`
- `bff/src/components/signals/signal-detail.tsx`

## Public Examples

### 1. REST API Design Best Practices
**URL:** https://restfulapi.net/

**Relevance:** Educational resource on RESTful API design patterns for CRUD operations. Demonstrates HTTP methods, status codes, resource naming conventions, and URL design applicable to FLUO's signal management API.

**Key Patterns:**
- Resource-oriented URL design (`/api/signals/{id}`)
- HTTP method semantics (GET for read, PATCH for partial update)
- Status code usage (200 OK, 201 Created, 404 Not Found)
- Pagination and filtering query parameters
- HATEOAS for resource discoverability

**FLUO Implementation:** Signal API endpoints follow RESTful conventions for CRUD operations on signal resources.

### 2. Django REST Framework
**URL:** https://www.django-rest-framework.org/

**Relevance:** Well-designed REST API framework demonstrating filtering, search, pagination, and serialization patterns. While FLUO uses Quarkus/Java, DRF's API design patterns are transferable.

**Key Patterns:**
- FilterSet for complex query filtering
- Serializer validation for input data
- Viewsets for CRUD operations
- Pagination classes (cursor, page number, limit/offset)
- Permission classes for authorization

**FLUO Alignment:** Signal filtering by trace ID, rule ID, severity, and status mirrors DRF's filter patterns.

### 3. Spring Data REST
**URL:** https://spring.io/projects/spring-data-rest

**Relevance:** Java-based REST API framework from Spring ecosystem (similar foundation to Quarkus). Demonstrates auto-generated REST APIs with search, filtering, and HATEOAS support.

**Key Patterns:**
- Repository-based REST endpoints
- Query method derivation (`findByStatusAndSeverity`)
- Paging and sorting support
- Custom search endpoints
- Spring Security integration for authorization

**FLUO Implementation:** FLUO's signal search/filter functionality can leverage similar repository query patterns with Quarkus Panache.
