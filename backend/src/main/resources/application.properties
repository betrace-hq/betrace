# FLUO Backend V2 Configuration

# Application settings
quarkus.application.name=fluo-backend-v2
quarkus.http.port=8080
quarkus.http.cors=true
quarkus.http.cors.origins=/.*/
quarkus.http.cors.headers=accept,authorization,content-type,x-requested-with
quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS

# WorkOS OAuth Configuration
# Replace these with your actual WorkOS credentials
workos.client.id=${WORKOS_CLIENT_ID:client_TEMP_WORKOS_CLIENT_ID}
workos.api.key=${WORKOS_API_KEY:sk_test_TEMP_WORKOS_SECRET_KEY}
workos.webhook.secret=${WORKOS_WEBHOOK_SECRET:whsec_TEMP_WEBHOOK_SECRET}
workos.redirect.uri=${WORKOS_REDIRECT_URI:http://localhost:8080/api/auth/callback}

# Allowed redirect URIs (comma-separated, exact match only)
# Security: Prevents open redirect attacks by validating OAuth redirect_uri parameter
# Format: http://localhost:3000/auth/callback,https://app.example.com/auth/callback
# Default: Localhost URIs for local development only
workos.allowed.redirect.uris=${WORKOS_ALLOWED_REDIRECT_URIS:http://localhost:8080/api/auth/callback,http://localhost:3000/api/auth/callback}

# Authentication Chain Signature Secret (HMAC-SHA256)
# Security P0: Prevents authentication bypass by ensuring ValidateWorkOSTokenProcessor actually executed
# CRITICAL: Must be set via environment variable AUTH_SIGNATURE_SECRET
# Generate with: openssl rand -base64 32
# Minimum length: 32 characters
# Example deployment:
#   export AUTH_SIGNATURE_SECRET=$(openssl rand -base64 32)
#   kubectl create secret generic fluo-auth --from-literal=AUTH_SIGNATURE_SECRET=$(openssl rand -base64 32)
auth.signature.secret=${AUTH_SIGNATURE_SECRET:test-secret-for-local-dev-only-minimum-32-chars-xxxxxxxxxxx}

# Previous Authentication Signature Secret (Optional - for key rotation)
# Set this to the old secret during key rotation to allow grace period
# Zero-downtime key rotation procedure:
#   1. Generate new secret: NEW_SECRET=$(openssl rand -base64 32)
#   2. Deploy with AUTH_SIGNATURE_SECRET=<new> and AUTH_SIGNATURE_SECRET_PREVIOUS=<old>
#   3. Wait for all pods to restart (signatures accepted from both secrets)
#   4. After grace period (e.g., 1 hour), remove AUTH_SIGNATURE_SECRET_PREVIOUS
# Default: Empty (no previous secret, no grace period)
auth.signature.secret.previous=${AUTH_SIGNATURE_SECRET_PREVIOUS:}

# WorkOS SSO Configuration
workos.sso.enabled=true
workos.sso.default.organization=${WORKOS_DEFAULT_ORG:org_TEMP_DEFAULT_ORG}
workos.timeout.seconds=5

# JWT Configuration for token validation
mp.jwt.verify.publickey.location=${JWT_PUBLIC_KEY:https://api.workos.com/.well-known/jwks.json}
mp.jwt.verify.issuer=${JWT_ISSUER:https://api.workos.com}
smallrye.jwt.sign.key.location=${JWT_SIGNING_KEY:/keys/privateKey.pem}

# Security Configuration
quarkus.http.auth.permission.authenticated.paths=/api/*
quarkus.http.auth.permission.authenticated.policy=authenticated
quarkus.http.auth.permission.public.paths=/api/auth/*,/health,/metrics,/q/*
quarkus.http.auth.permission.public.policy=permit

# Circuit Breaker Configuration (SmallRye Fault Tolerance)
# Protects against cascading failures from downstream service outages
# SOC2 CC7.2 (System Performance) - Prevents resource exhaustion
# Configuration for SignalService.evaluateRules() circuit breaker:
# - Opens after 5 failures in 10 requests (50% threshold)
# - Stays open for 5 seconds before attempting half-open
# - Requires 3 successful calls to close circuit
# - 10 second timeout for rule evaluation
# Default: Annotation-based configuration (see @CircuitBreaker in SignalService)

# Role-based Access Control Mappings
# Define role requirements for different operations
fluo.security.roles.signal.read=signal:read,admin
fluo.security.roles.signal.write=signal:write,admin
fluo.security.roles.rule.read=rule:read,rule:write,admin
fluo.security.roles.rule.write=rule:write,admin
fluo.security.roles.span.write=span:write,telemetry:write,admin

# Tenant Isolation Configuration
fluo.security.tenant.isolation=true
fluo.security.tenant.header=X-Tenant-ID
fluo.security.tenant.validation.enabled=true

# Camel Configuration
camel.springboot.name=fluo-backend
camel.context.stream-caching.enabled=true
camel.rest.binding-mode=json
camel.rest.context-path=/api
camel.rest.api-context-path=/api-doc
camel.rest.enable-cors=true

# TigerBeetle Configuration (placeholder)
tigerbeetle.cluster.id=${TIGERBEETLE_CLUSTER_ID:0}
tigerbeetle.addresses=${TIGERBEETLE_ADDRESSES:localhost:3000}

# OpenTelemetry Configuration for Compliance Tracking
quarkus.otel.enabled=true
quarkus.otel.exporter.otlp.endpoint=${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4317}
quarkus.otel.exporter.otlp.headers=${OTEL_EXPORTER_OTLP_HEADERS:}
quarkus.otel.exporter.otlp.timeout=10s
quarkus.otel.resource.attributes=service.name=fluo-backend,service.version=1.0.0,deployment.environment=${ENV:development}

# Compliance-specific span configuration
quarkus.otel.traces.sampler=always_on
quarkus.otel.traces.sampler.arg=1.0
quarkus.otel.propagators=tracecontext,baggage

# Span processors for compliance (custom)
compliance.span.processor.enabled=true
compliance.span.processor.frameworks=SOC2,HIPAA,FedRAMP,ISO27001,PCI-DSS

# Health Check Configuration
quarkus.smallrye-health.root-path=/health

# Metrics Configuration
quarkus.micrometer.enabled=true
quarkus.micrometer.export.prometheus.enabled=true
quarkus.micrometer.export.prometheus.path=/metrics

# Pyroscope Profiling Configuration
pyroscope.server.address=http://localhost:4040
pyroscope.application.name=fluo-backend
pyroscope.profiler.event=cpu
pyroscope.profiler.alloc=512k
pyroscope.profiler.lock=10ms
pyroscope.upload.interval=10s

# Logging Configuration
quarkus.log.level=INFO
quarkus.log.category."com.fluo".level=DEBUG
quarkus.log.category."org.apache.camel".level=INFO
quarkus.log.category."com.fluo.security".level=DEBUG
quarkus.log.console.enable=true
quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n

# Development Mode Settings
%dev.quarkus.http.port=8080
%dev.quarkus.live-reload.password=changeme
%dev.quarkus.log.level=WARN
%dev.quarkus.log.category."com.fluo".level=DEBUG
%dev.quarkus.log.category."io.quarkus".level=WARN
%dev.quarkus.log.category."org.apache.camel".level=WARN
%dev.quarkus.log.category."io.opentelemetry".level=WARN
%dev.quarkus.log.category."org.jboss".level=WARN
%dev.quarkus.log.category."io.netty".level=WARN
%dev.workos.sso.enabled=false
%dev.fluo.security.tenant.validation.enabled=false

# Dev Services Configuration
%dev.quarkus.devservices.enabled=true
%dev.quarkus.otel.devservices.enabled=false

# Test Mode Settings
%test.quarkus.http.test-port=8081
%test.workos.sso.enabled=false
%test.fluo.security.tenant.validation.enabled=false

# Production Mode Settings
%prod.quarkus.http.port=8080
%prod.quarkus.log.level=INFO
%prod.workos.sso.enabled=true
%prod.fluo.security.tenant.validation.enabled=true

# S3-compatible storage configuration for rules
s3.bucket.name=fluo-rules

# S3 polling configuration (in milliseconds)
s3.poll.delay=30000

# AWS2-S3 Component Configuration
# For AWS S3
camel.component.aws2-s3.region=us-east-1
# camel.component.aws2-s3.access-key=YOUR_ACCESS_KEY
# camel.component.aws2-s3.secret-key=YOUR_SECRET_KEY

# For S3-compatible services like MinIO
# camel.component.aws2-s3.override-endpoint=true
# camel.component.aws2-s3.uri-endpoint-override=http://localhost:9000
# camel.component.aws2-s3.path-style-access=true
# camel.component.aws2-s3.access-key=minioadmin
# camel.component.aws2-s3.secret-key=minioadmin

# Caffeine Cache Configuration
camel.component.caffeine-cache.cache-loader-enabled=false
camel.component.caffeine-cache.cache-writer-enabled=false

# Cache policies for high-performance use cases
# Rule cache - rules rarely change but are frequently accessed
fluo.cache.rules.max-size=1000
fluo.cache.rules.expire-after-write=1h
fluo.cache.rules.expire-after-access=30m

# Session cache - for user sessions and authentication data
fluo.cache.sessions.max-size=10000
fluo.cache.sessions.expire-after-write=24h
fluo.cache.sessions.expire-after-access=2h

# Rule validation cache - for OGNL expression compilation
fluo.cache.rule-validation.max-size=500
fluo.cache.rule-validation.expire-after-write=6h
fluo.cache.rule-validation.expire-after-access=1h

# Rate Limiting Configuration (PRD-007c)
fluo.ratelimit.tenant.requests-per-minute=1000
fluo.ratelimit.user.requests-per-minute=100
fluo.ratelimit.anonymous.requests-per-minute=10
fluo.ratelimit.exempt-paths=/q/health,/q/metrics,/q/openapi,/api/public/status

# DuckDB shared database for rate limiting
fluo.storage.system.ratelimits-path=./data/system/ratelimits.duckdb

# TigerBeetle Event Ledger (PRD-002a)
# Immutable ledger for signals and rules persistence
tigerbeetle.cluster-id=0
tigerbeetle.addresses=127.0.0.1:3000
fluo.rules.storage-path=./data-rules

# DuckDB Hot Storage (PRD-002b)
fluo.duckdb.storage-path=./data-duckdb
fluo.duckdb.hot-retention-days=7

# KMS Configuration (PRD-006a: Pluggable KMS Architecture)
# Ports-and-adapters design for deployment-agnostic encryption
# Supported providers: local, aws, vault, gcp, azure
# SOC2 CC6.1 (Logical Access Controls), HIPAA 164.312(a)(2)(iv) (Encryption/Decryption)

# KMS Provider Selection
fluo.kms.provider=${KMS_PROVIDER:local}

# AWS KMS Configuration (provider=aws)
# Requires: aws.kms.region, aws.kms.master-key-id
# Authentication: DefaultCredentialsProvider chain (env vars, IAM role, ~/.aws/credentials)
aws.kms.region=${AWS_REGION:us-east-1}
aws.kms.master-key-id=${AWS_KMS_MASTER_KEY_ID:}
aws.kms.endpoint=${AWS_KMS_ENDPOINT:}

# HashiCorp Vault Configuration (provider=vault)
# TODO: Implement VaultKmsAdapter
# vault.addr=${VAULT_ADDR:http://localhost:8200}
# vault.token=${VAULT_TOKEN:}
# vault.transit.mount=${VAULT_TRANSIT_MOUNT:transit}
# vault.transit.key-name=${VAULT_KEY_NAME:fluo-master-key}

# Google Cloud KMS Configuration (provider=gcp)
# TODO: Implement GcpKmsAdapter
# gcp.kms.project-id=${GCP_PROJECT_ID:}
# gcp.kms.location=${GCP_KMS_LOCATION:us-east1}
# gcp.kms.keyring=${GCP_KMS_KEYRING:fluo-keyring}
# gcp.kms.key-name=${GCP_KMS_KEY_NAME:fluo-master-key}

# Azure Key Vault Configuration (provider=azure)
# TODO: Implement AzureKmsAdapter
# azure.keyvault.uri=${AZURE_KEYVAULT_URI:}
# azure.keyvault.key-name=${AZURE_KEY_NAME:fluo-master-key}
# azure.keyvault.tenant-id=${AZURE_TENANT_ID:}
# azure.keyvault.client-id=${AZURE_CLIENT_ID:}
# azure.keyvault.client-secret=${AZURE_CLIENT_SECRET:}

# Development Mode: Use LocalKmsAdapter (in-memory, NOT FOR PRODUCTION)
%dev.fluo.kms.provider=local

# LocalStack for AWS KMS testing (provider=aws with LocalStack endpoint)
%dev.aws.kms.endpoint=http://localhost:4566
%dev.aws.kms.master-key-id=alias/fluo-dev-master-key

# Key Storage Configuration (PRD-006b: Key Generation Service)
# Filesystem path for encrypted tenant keys (encrypted with KMS master key)
fluo.kms.key-store-path=${FLUO_KEY_STORE_PATH:./data/keys}