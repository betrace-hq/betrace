package simulation

import (
	"fmt"

	"github.com/betracehq/betrace/backend/pkg/models"
)

// WorkloadGenerator creates realistic spans and rules for simulation testing
type WorkloadGenerator struct {
	rand *DeterministicRand
}

// NewWorkloadGenerator creates a generator with the given random source
func NewWorkloadGenerator(rand *DeterministicRand) *WorkloadGenerator {
	return &WorkloadGenerator{rand: rand}
}

// GenerateSpan creates a realistic span with random attributes
func (w *WorkloadGenerator) GenerateSpan(traceID, spanID string) *models.Span {
	serviceName := w.rand.Choice([]string{
		"frontend", "backend", "database", "cache", "auth-service", "payment-service",
	})

	operationName := w.rand.Choice([]string{
		"http.request", "db.query", "cache.get", "grpc.call", "auth.check", "payment.process",
	})

	status := w.rand.Choice([]string{"OK", "ERROR", "TIMEOUT"})

	// Duration: 1ms to 5 seconds
	duration := w.rand.Duration(1_000_000, 5_000_000_000)

	// Random attributes (1-10 attributes per span)
	attrCount := w.rand.Intn(10) + 1
	attributes := make(map[string]string)
	for i := 0; i < attrCount; i++ {
		key := w.rand.Choice([]string{
			"http.method", "http.status_code", "http.url", "db.statement",
			"user.id", "session.id", "error.type", "cache.hit",
		})
		value := w.randomAttributeValue(key)
		attributes[key] = value
	}

	return &models.Span{
		TraceID:       traceID,
		SpanID:        spanID,
		ServiceName:   serviceName,
		OperationName: operationName,
		Status:        status,
		Duration:      duration,
		Attributes:    attributes,
	}
}

// randomAttributeValue generates realistic attribute values based on key
func (w *WorkloadGenerator) randomAttributeValue(key string) string {
	switch key {
	case "http.method":
		return w.rand.Choice([]string{"GET", "POST", "PUT", "DELETE", "PATCH"})
	case "http.status_code":
		return w.rand.Choice([]string{"200", "201", "400", "401", "403", "404", "500", "503"})
	case "http.url":
		return fmt.Sprintf("/api/%s/%d", w.rand.Choice([]string{"users", "orders", "products"}), w.rand.Intn(1000))
	case "db.statement":
		return w.rand.Choice([]string{"SELECT", "INSERT", "UPDATE", "DELETE"})
	case "user.id":
		return fmt.Sprintf("user-%d", w.rand.Intn(10000))
	case "session.id":
		return w.rand.UUID()
	case "error.type":
		return w.rand.Choice([]string{"timeout", "connection_refused", "permission_denied", "not_found"})
	case "cache.hit":
		return w.rand.Choice([]string{"true", "false"})
	default:
		return w.rand.String(10)
	}
}

// GenerateTrace creates a complete trace with multiple spans
func (w *WorkloadGenerator) GenerateTrace(spanCount int) []*models.Span {
	traceID := w.rand.UUID()
	spans := make([]*models.Span, spanCount)

	for i := 0; i < spanCount; i++ {
		spanID := w.rand.UUID()
		spans[i] = w.GenerateSpan(traceID, spanID)
	}

	return spans
}

// GenerateRule creates a random rule expression
func (w *WorkloadGenerator) GenerateRule(id string) models.Rule {
	expression := w.randomExpression()

	severity := w.rand.Choice([]string{"LOW", "MEDIUM", "HIGH", "CRITICAL"})

	return models.Rule{
		ID:          id,
		Name:        fmt.Sprintf("rule-%s", id),
		Description: "Generated by simulation workload",
		Expression:  expression,
		Severity:    severity,
		Enabled:     true,
	}
}

// randomExpression generates realistic rule expressions
func (w *WorkloadGenerator) randomExpression() string {
	patterns := []string{
		// Span-level rules
		`span.status == "ERROR"`,
		`span.duration > 1000`,
		`span.attributes["http.status_code"] == "500"`,
		`span.attributes["http.status_code"] >= "400"`,
		`span.duration > 2000 and span.status == "OK"`,

		// Trace-level rules
		`trace.has(span.name == "auth.check")`,
		`trace.has(span.name == "auth.check") and trace.has(span.name == "db.query")`,
		`trace.has(span.status == "ERROR")`,
		`trace.has(span.duration > 3000)`,
		`trace.has(span.attributes["cache.hit"] == "false") and trace.has(span.name == "db.query")`,

		// Complex combinations
		`span.status == "ERROR" or span.duration > 5000`,
		`span.attributes["http.method"] == "POST" and span.status == "ERROR"`,
		`span.duration > 1000 and (span.status == "ERROR" or span.status == "TIMEOUT")`,
	}

	return w.rand.Choice(patterns)
}

// WorkloadProfile defines the characteristics of a simulation workload
type WorkloadProfile struct {
	Name             string
	RuleCount        int     // Number of active rules
	SpansPerSecond   int     // Span ingestion rate
	TraceCount       int     // Number of concurrent traces
	SpansPerTrace    int     // Average spans per trace
	RuleUpdateRate   float64 // Probability of rule CRUD per second (0.0 to 1.0)
	BurstProbability float64 // Probability of traffic burst (0.0 to 1.0)
	BurstMultiplier  int     // Multiplier during burst (e.g., 10x)
}

// SteadyStateWorkload returns a typical production workload profile
func SteadyStateWorkload() WorkloadProfile {
	return WorkloadProfile{
		Name:             "steady-state",
		RuleCount:        100,
		SpansPerSecond:   1000,
		TraceCount:       50,
		SpansPerTrace:    20,
		RuleUpdateRate:   0.1,  // 10% chance per second
		BurstProbability: 0.0,  // No bursts
		BurstMultiplier:  1,
	}
}

// BurstWorkload returns a workload with traffic spikes
func BurstWorkload() WorkloadProfile {
	return WorkloadProfile{
		Name:             "burst",
		RuleCount:        100,
		SpansPerSecond:   1000,
		TraceCount:       50,
		SpansPerTrace:    20,
		RuleUpdateRate:   0.1,
		BurstProbability: 0.2,  // 20% chance of burst per second
		BurstMultiplier:  10,   // 10x traffic during burst
	}
}

// AdversarialWorkload returns a workload designed to stress the system
func AdversarialWorkload() WorkloadProfile {
	return WorkloadProfile{
		Name:             "adversarial",
		RuleCount:        200,
		SpansPerSecond:   5000,
		TraceCount:       200,
		SpansPerTrace:    100,   // Very long traces
		RuleUpdateRate:   0.5,   // Frequent rule changes
		BurstProbability: 0.3,
		BurstMultiplier:  20,
	}
}
