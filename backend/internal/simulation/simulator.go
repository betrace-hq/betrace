package simulation

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/betracehq/betrace/backend/internal/rules"
	"github.com/betracehq/betrace/backend/internal/services"
	"github.com/betracehq/betrace/backend/internal/storage"
	"github.com/betracehq/betrace/backend/pkg/models"
)

// Simulator orchestrates deterministic simulation testing
// Inspired by TigerBeetle's VOPR and FoundationDB's simulation framework
type Simulator struct {
	// Deterministic components
	seed      int64
	rand      *DeterministicRand
	clock     *VirtualClock
	workload  *WorkloadGenerator

	// System under test
	engine      *rules.RuleEngine
	ruleStore   *storage.DiskRuleStore
	traceBuffer *services.TraceBuffer
	filesystem  *storage.MockFileSystem

	// Simulation state
	activeRules  map[string]models.Rule
	activeTraces map[string][]*models.Span
	violations   []models.Violation

	// Statistics
	stats SimulationStats
}

// SimulationStats tracks metrics during a simulation run
type SimulationStats struct {
	StartTime       time.Time
	EndTime         time.Time
	SimulatedTime   time.Duration
	RealTime        time.Duration
	SpeeupFactor    float64

	SpansGenerated  int
	TracesCompleted int
	RulesCreated    int
	RulesEvaluated  int
	ViolationsFound int

	CrashesInjected int
	FaultsInjected  int
	InvariantChecks int
	InvariantFails  int
}

// NewSimulator creates a new deterministic simulator with the given seed
func NewSimulator(seed int64) *Simulator {
	rand := NewDeterministicRand(seed)
	clock := NewVirtualClock(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC))

	// Create mock filesystem for deterministic I/O
	mockFS := storage.NewMockFileSystem()

	// Create disk-backed rule store with mock filesystem
	ruleStore, err := storage.NewDiskRuleStoreWithFS("/simulation/data", mockFS)
	if err != nil {
		panic(fmt.Sprintf("Failed to create rule store: %v", err))
	}

	// Create rule engine
	engine := rules.NewRuleEngine()

	// Create trace buffer with virtual time
	traceBuffer := services.NewTraceBuffer(3*time.Second, func(ctx context.Context, traceID string, spans []*models.Span) {
		// Trace completed callback (evaluates rules)
		// This will be enhanced in Phase 2
	})

	sim := &Simulator{
		seed:         seed,
		rand:         rand,
		clock:        clock,
		workload:     NewWorkloadGenerator(rand),
		engine:       engine,
		ruleStore:    ruleStore,
		traceBuffer:  traceBuffer,
		filesystem:   mockFS,
		activeRules:  make(map[string]models.Rule),
		activeTraces: make(map[string][]*models.Span),
		violations:   make([]models.Violation, 0, 1000),
		stats: SimulationStats{
			StartTime: clock.Now(),
		},
	}

	return sim
}

// Seed returns the simulation seed (for reproduction)
func (s *Simulator) Seed() int64 {
	return s.seed
}

// Now returns the current simulated time
func (s *Simulator) Now() time.Time {
	return s.clock.Now()
}

// Advance moves simulated time forward
func (s *Simulator) Advance(d time.Duration) {
	s.clock.Advance(d)
}

// CreateRule adds a new rule to the system
func (s *Simulator) CreateRule(expression string) models.Rule {
	id := s.rand.UUID()
	rule := models.Rule{
		ID:          id,
		Name:        fmt.Sprintf("rule-%s", id[:8]),
		Description: "Generated by simulator",
		Expression:  expression,
		Severity:    s.rand.Choice([]string{"LOW", "MEDIUM", "HIGH", "CRITICAL"}),
		Enabled:     true,
	}

	// Load into engine
	if err := s.engine.LoadRule(rule); err != nil {
		log.Printf("Failed to load rule: %v", err)
		return rule
	}

	// Persist to disk
	if err := s.ruleStore.Create(rule); err != nil {
		log.Printf("Failed to persist rule: %v", err)
		return rule
	}

	s.activeRules[rule.ID] = rule
	s.stats.RulesCreated++

	return rule
}

// GenerateRule creates a rule with random expression
func (s *Simulator) GenerateRule() models.Rule {
	id := s.rand.UUID()
	rule := s.workload.GenerateRule(id)

	if err := s.engine.LoadRule(rule); err != nil {
		log.Printf("Failed to load rule: %v", err)
		return rule
	}

	if err := s.ruleStore.Create(rule); err != nil {
		log.Printf("Failed to persist rule: %v", err)
		return rule
	}

	s.activeRules[rule.ID] = rule
	s.stats.RulesCreated++

	return rule
}

// SendSpan injects a span into the trace buffer
func (s *Simulator) SendSpan(span *models.Span) {
	s.traceBuffer.AddSpan(span)
	s.activeTraces[span.TraceID] = append(s.activeTraces[span.TraceID], span)
	s.stats.SpansGenerated++
}

// GenerateSpans creates and sends random spans
func (s *Simulator) GenerateSpans(count int) {
	for i := 0; i < count; i++ {
		traceID := s.rand.UUID()
		spanID := s.rand.UUID()
		span := s.workload.GenerateSpan(traceID, spanID)
		s.SendSpan(span)
	}
}

// GetRules returns all active rules
func (s *Simulator) GetRules() []models.Rule {
	rules := make([]models.Rule, 0, len(s.activeRules))
	for _, rule := range s.activeRules {
		rules = append(rules, rule)
	}
	return rules
}

// GetRule retrieves a rule by ID
func (s *Simulator) GetRule(id string) (models.Rule, error) {
	return s.ruleStore.Get(id)
}

// DeleteRule removes a rule from the system
func (s *Simulator) DeleteRule(id string) error {
	s.engine.DeleteRule(id)

	if err := s.ruleStore.Delete(id); err != nil {
		return err
	}

	delete(s.activeRules, id)
	return nil
}

// CrashAndRestart simulates ungraceful shutdown and recovery
func (s *Simulator) CrashAndRestart() error {
	s.stats.CrashesInjected++

	// Kill the engine (lose in-memory state)
	s.engine = rules.NewRuleEngine()
	s.activeRules = make(map[string]models.Rule)

	// Recreate trace buffer (lose buffered traces)
	s.traceBuffer = services.NewTraceBuffer(3*time.Second, func(ctx context.Context, traceID string, spans []*models.Span) {
		// Trace completed callback
	})

	// Recreate rule store from same filesystem (persistent state)
	ruleStore, err := storage.NewDiskRuleStoreWithFS("/simulation/data", s.filesystem)
	if err != nil {
		return fmt.Errorf("failed to recover rule store: %w", err)
	}
	s.ruleStore = ruleStore

	// Reload rules from disk
	recoveredRules, err := s.ruleStore.List()
	if err != nil {
		return fmt.Errorf("failed to list rules: %w", err)
	}

	for _, rule := range recoveredRules {
		if err := s.engine.LoadRule(rule); err != nil {
			log.Printf("Failed to reload rule %s: %v", rule.ID, err)
			continue
		}
		s.activeRules[rule.ID] = rule
	}

	return nil
}

// Stats returns the current simulation statistics
func (s *Simulator) Stats() SimulationStats {
	stats := s.stats
	stats.EndTime = s.clock.Now()
	stats.SimulatedTime = stats.EndTime.Sub(stats.StartTime)
	return stats
}

// Run executes a simulation for the given duration with the specified workload
func (s *Simulator) Run(duration time.Duration, profile WorkloadProfile) error {
	realStart := time.Now()

	// Phase 1: Setup - create initial rules
	for i := 0; i < profile.RuleCount; i++ {
		s.GenerateRule()
	}

	// Phase 2: Run workload
	endTime := s.clock.Now().Add(duration)
	tick := 0

	for s.clock.Now().Before(endTime) {
		tick++

		// Generate spans based on profile
		spansThisTick := profile.SpansPerSecond / 10 // Assume 10 ticks per second

		// Check for burst
		if s.rand.Chance(profile.BurstProbability) {
			spansThisTick *= profile.BurstMultiplier
		}

		s.GenerateSpans(spansThisTick)

		// Occasional rule updates
		if s.rand.Chance(profile.RuleUpdateRate / 10) {
			if s.rand.Bool() {
				// Create new rule
				s.GenerateRule()
			} else if len(s.activeRules) > 0 {
				// Delete random rule
				rules := s.GetRules()
				if len(rules) > 0 {
					toDelete := rules[s.rand.Intn(len(rules))]
					_ = s.DeleteRule(toDelete.ID)
				}
			}
		}

		// Advance time by 100ms per tick
		s.Advance(100 * time.Millisecond)
	}

	// Calculate final stats
	s.stats.EndTime = s.clock.Now()
	s.stats.SimulatedTime = s.stats.EndTime.Sub(s.stats.StartTime)
	s.stats.RealTime = time.Since(realStart)

	if s.stats.RealTime > 0 {
		s.stats.SpeeupFactor = float64(s.stats.SimulatedTime) / float64(s.stats.RealTime)
	}

	return nil
}

// Report prints a simulation summary
func (s *Simulator) Report() {
	stats := s.Stats()
	fmt.Printf("\n=== Simulation Report (Seed: %d) ===\n", s.seed)
	fmt.Printf("Simulated Time: %v\n", stats.SimulatedTime)
	fmt.Printf("Real Time: %v\n", stats.RealTime)
	fmt.Printf("Speedup: %.1fx\n", stats.SpeeupFactor)
	fmt.Printf("\n")
	fmt.Printf("Spans Generated: %d\n", stats.SpansGenerated)
	fmt.Printf("Traces Completed: %d\n", stats.TracesCompleted)
	fmt.Printf("Rules Created: %d\n", stats.RulesCreated)
	fmt.Printf("Rules Evaluated: %d\n", stats.RulesEvaluated)
	fmt.Printf("Violations Found: %d\n", stats.ViolationsFound)
	fmt.Printf("\n")
	fmt.Printf("Crashes Injected: %d\n", stats.CrashesInjected)
	fmt.Printf("Faults Injected: %d\n", stats.FaultsInjected)
	fmt.Printf("Invariant Checks: %d\n", stats.InvariantChecks)
	fmt.Printf("Invariant Failures: %d\n", stats.InvariantFails)
	fmt.Printf("\n")
}
